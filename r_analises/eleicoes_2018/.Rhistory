#================================================================#
# Bibliotecas
library(ggplot2)
library(dplyr)
library(maps)
library(ggmap)
library(mongolite)
library(lubridate)
library(gridExtra)
library(leaflet)
library(leaflet.extras)
require (sqldf)
library(RColorBrewer)
library(htmltools)
library(shiny)
library(flexdashboard)
library(datasets)
# inserir collections nos dataframes
#================================================================#
# Partidos
"
Sigla
Nome
Legenda
Espectro
"
if(db_access == 'remote'){
col_partidos <- mongo(collection = "lista_partidos", db="eleicoes", url = "mongodb+srv://dbuser:Xk5Jp8n5rHaXmtM@cluster0-tpq89.mongodb.net/test?retryWrites=true&w=majority")
} else { # Local
col_partidos <- mongo("lista_partidos", url = "mongodb://localhost:27017/eleicoes")
}
df_partidos = col_partidos$find ('{}')
#================================================================#
# Locais de votação
"
Zona
Seção
Local
Latitude
Longitude
Local Seção
Endereço
Bairro
IdBairro
Cidade
"
if(db_access == 'remote'){
col_locais_votacao <- mongo(collection = "locais_votacao", db="eleicoes", url = "mongodb+srv://dbuser:Xk5Jp8n5rHaXmtM@cluster0-tpq89.mongodb.net/test?retryWrites=true&w=majority")
} else { # Local
col_locais_votacao <- mongo("locais_votacao", url = "mongodb://localhost:27017/eleicoes")
}
df_locais_votacao = col_locais_votacao$find ('{}')
# Converter as colunas de latitude e longitude de valores `character` para `numeric`
df_locais_votacao$NR_LATITUDE <- as.numeric(df_locais_votacao$NR_LATITUDE)
df_locais_votacao$NR_LONGITUDE <- as.numeric(df_locais_votacao$NR_LONGITUDE)
# sapply(df_locais_votacao, class)
#================================================================#
# Votos por seção (eleições gerais 2018)
"
DT_GERACAO
HH_GERACAO
AA_GERACAO
CD_TIPO_ELEICAO
NM_TIPO_ELEICAO
NR_TURNO
CD_ELEICAO
DS_ELEICAO
DT_ELEICAO
TP_ABRANGENCIA
SG_UF
SG_UE
NM_UE
CD_MUNICIPIO
NM_MUNICIPIO
NR_ZONA *
NR_SECAO *
CD_CARGO *
DS_CARGO *
NR_VOTAVEL *
NR_PARTIDO *
NM_VOTAVEL *
QT_VOTOS *
"
"
Excluindo-se logo de cara os dados do segundo turno e considerando apenas os votos válidos,
ou seja, desconsiderando os votos brancos e nulos (95,96)
"
if(db_access == 'remote'){
col_secao_votacao_gerais <- mongo(collection = "secao_votacao_gerais_2018", db="eleicoes", url = "mongodb+srv://dbuser:Xk5Jp8n5rHaXmtM@cluster0-tpq89.mongodb.net/test?retryWrites=true&w=majority")
} else { # Local
col_secao_votacao_gerais <- mongo("secao_votacao_gerais", url = "mongodb://localhost:27017/eleicoes")
}
df_votos_validos = col_secao_votacao_gerais$find(
query =  '{"NR_TURNO": "1", "CD_CARGO": {"NR_VOTAVEL": {"$nin": ["95", "96"]} }',
fields = '{"NR_ZONA": "1", "NR_SECAO": "1", "CD_CARGO": "1", "DS_CARGO": "1", "NR_VOTAVEL": "1", "NR_PARTIDO": "1", "NM_VOTAVEL": "1", "QT_VOTOS": "1"}',
sort = '{}'
)
# Validar json
#js <- '[{"NR_TURNO": "1", "CD_CARGO": { "$in": ["6", "7"]} }, ]'
#jsonlite::fromJSON(js)
#================================================================#
# Chunk 1: config
#================================================================#
# Definindo o ambiente
ambiente = 'appleMac'
db_access <<- 'remote' # define o local de acesso aos dados, se remote, então acessa o atlasDB
switch(ambiente,
windowsPc={
setwd('C:/Users/heavyrick/Desktop/datascience/r_analises/eleicoes_2018')
},
windowsNote={
setwd('C:/Users/ricardo/Desktop/ds/datascience/r_analises/eleicoes_2018')
},
linuxPC={
setwd('/home/usuario/www/repositorios/datascience/kbase/R')
},
appleMac={
setwd('/Users/ricardoalmeida/ds/datascience/r_analises/eleicoes_2018')
}
)
#================================================================#
# Carregar dados
source(file = "load_data.R")
# Chunk 2: df_df1
# Os votos ficam na base `df_secao_votacao_gerais` e devem ser juntados com a base `df_partidos`.
# Temos que retornar a quantidade de votos por sigla partidária, não mostrando os que não tiveram votos.
title_text = 'Eleições gerais 2018 | Americana '
votos_partido_df = sqldf("
SELECT p.Sigla, SUM(v.QT_VOTOS) as Votos
FROM df_partidos p
LEFT JOIN df_votos_validos v ON p.Legenda = v.NR_PARTIDO
GROUP BY p.Sigla
HAVING SUM(v.QT_VOTOS) > 0
ORDER BY Votos DESC
")
# O gráfico primeiro é preparado ordendando as colunas por quantidade de votos
# a propriedade fill dá um degradê interessante para a contagem
votos_partido_chart <- ggplot(
votos_partido_df, aes(
x = reorder(Sigla, -Votos),
y = Votos,
fill=as.factor(Votos)
)
)
# Gráfico de barras horizontais para mostrar as votações
# Fosse vertical os nomes iam ficar difíceis de ler, iam ficar encavalados
votos_partido_func <- function() {
votos_partido_chart +
geom_bar(stat = "identity") +
scale_fill_grey(start = 0.65, end = 0.20) +
coord_flip() +
ggtitle(paste(title_text, 'Votos por partido')) +
xlab('Partidos') +
ylab('Qtde Votos') +
theme(legend.position="none",
plot.title = element_text(size = 11, face='bold'),
axis.title = element_text(size=12, color='black'))
}
# Chunk 3
votos_partido_func()
# Chunk 4
# Select dos dados
candidatos_votados_df = sqldf("
SELECT p.Sigla, COUNT(DISTINCT v.NR_VOTAVEL) as Candidatos
FROM df_partidos p
INNER JOIN df_votos_validos v ON p.Legenda = v.NR_PARTIDO
GROUP BY p.Sigla
ORDER BY Candidatos DESC
")
candidatos_votados_chart <- ggplot(
candidatos_votados_df, aes(
x = reorder(Sigla, -Candidatos),
y = Candidatos,
fill=as.factor(Candidatos)
)
)
candidatos_votados_func <- function() {
candidatos_votados_chart +
geom_bar(stat = "identity") +
scale_fill_grey(start = 0.85, end = 0.20) +
coord_flip() +
ggtitle(paste('Quantidade de candidatos que receberam votos por partido'), subtitle = title_text) +
xlab('Partidos') +
ylab('Qtde Candidatos') +
theme(legend.position="none",
plot.title = element_text(size = 11, face='bold'),
axis.title = element_text(size=12, color='black'))
}
# Chunk 5
candidatos_votados_func()
# Chunk 6
sliderInput("bw_adjust", label = "Bandwidth adjustment:",
min = 0.2, max = 2, value = 1, step = 0.2)
partidos_df = sqldf("
SELECT p.*
FROM df_partidos p
ORDER BY p.sigla ASC
")
# Chunk 1: config
#================================================================#
# Definindo o ambiente
ambiente = 'appleMac'
db_access <<- 'remote' # define o local de acesso aos dados, se remote, então acessa o atlasDB
switch(ambiente,
windowsPc={
setwd('C:/Users/heavyrick/Desktop/datascience/r_analises/eleicoes_2018')
},
windowsNote={
setwd('C:/Users/ricardo/Desktop/ds/datascience/r_analises/eleicoes_2018')
},
linuxPC={
setwd('/home/usuario/www/repositorios/datascience/kbase/R')
},
appleMac={
setwd('/Users/ricardoalmeida/ds/datascience/r_analises/eleicoes_2018')
}
)
#================================================================#
# Carregar dados
source(file = "load_data.R")
# Chunk 2: df_df1
# Os votos ficam na base `df_secao_votacao_gerais` e devem ser juntados com a base `df_partidos`.
# Temos que retornar a quantidade de votos por sigla partidária, não mostrando os que não tiveram votos.
title_text = 'Eleições gerais 2018 | Americana '
votos_partido_df = sqldf("
SELECT p.Sigla, SUM(v.QT_VOTOS) as Votos
FROM df_partidos p
LEFT JOIN df_votos_validos v ON p.Legenda = v.NR_PARTIDO
GROUP BY p.Sigla
HAVING SUM(v.QT_VOTOS) > 0
ORDER BY Votos DESC
")
# O gráfico primeiro é preparado ordendando as colunas por quantidade de votos
# a propriedade fill dá um degradê interessante para a contagem
votos_partido_chart <- ggplot(
votos_partido_df, aes(
x = reorder(Sigla, -Votos),
y = Votos,
fill=as.factor(Votos)
)
)
# Gráfico de barras horizontais para mostrar as votações
# Fosse vertical os nomes iam ficar difíceis de ler, iam ficar encavalados
votos_partido_func <- function() {
votos_partido_chart +
geom_bar(stat = "identity") +
scale_fill_grey(start = 0.65, end = 0.20) +
coord_flip() +
ggtitle(paste(title_text, 'Votos por partido')) +
xlab('Partidos') +
ylab('Qtde Votos') +
theme(legend.position="none",
plot.title = element_text(size = 11, face='bold'),
axis.title = element_text(size=12, color='black'))
}
# Chunk 3
votos_partido_func()
# Chunk 4
# Select dos dados
candidatos_votados_df = sqldf("
SELECT p.Sigla, COUNT(DISTINCT v.NR_VOTAVEL) as Candidatos
FROM df_partidos p
INNER JOIN df_votos_validos v ON p.Legenda = v.NR_PARTIDO
GROUP BY p.Sigla
ORDER BY Candidatos DESC
")
candidatos_votados_chart <- ggplot(
candidatos_votados_df, aes(
x = reorder(Sigla, -Candidatos),
y = Candidatos,
fill=as.factor(Candidatos)
)
)
candidatos_votados_func <- function() {
candidatos_votados_chart +
geom_bar(stat = "identity") +
scale_fill_grey(start = 0.85, end = 0.20) +
coord_flip() +
ggtitle(paste('Quantidade de candidatos que receberam votos por partido'), subtitle = title_text) +
xlab('Partidos') +
ylab('Qtde Candidatos') +
theme(legend.position="none",
plot.title = element_text(size = 11, face='bold'),
axis.title = element_text(size=12, color='black'))
}
# Chunk 5
candidatos_votados_func()
# Chunk 6
sliderInput("bw_adjust", label = "Bandwidth adjustment:",
min = 0.2, max = 2, value = 1, step = 0.2)
partidos_df = sqldf("
SELECT p.*
FROM df_partidos p
ORDER BY p.sigla ASC
")
#================================================================#
# Definindo o ambiente
ambiente = 'appleMac'
db_access <<- 'remote' # define o local de acesso aos dados, se remote, então acessa o atlasDB
switch(ambiente,
windowsPc={
setwd('C:/Users/heavyrick/Desktop/datascience/r_analises/eleicoes_2018')
},
windowsNote={
setwd('C:/Users/ricardo/Desktop/ds/datascience/r_analises/eleicoes_2018')
},
linuxPC={
setwd('/home/usuario/www/repositorios/datascience/kbase/R')
},
appleMac={
setwd('/Users/ricardoalmeida/ds/datascience/r_analises/eleicoes_2018')
}
)
#================================================================#
# Carregar dados
source(file = "load_data.R")
View(votos_partido_chart)
View(votos_partido_df)
votos_partido_df = sqldf("
SELECT p.Sigla, SUM(v.QT_VOTOS) as Votos
FROM df_partidos p
LEFT JOIN df_votos_validos v ON p.Legenda = v.NR_PARTIDO
WHERE v.CD_CARGO = 3
GROUP BY p.Sigla
HAVING SUM(v.QT_VOTOS) > 0
ORDER BY Votos DESC
")
votos_partido_dep_estadual_df = sqldf("
SELECT p.Sigla, SUM(v.QT_VOTOS) as Votos
FROM df_partidos p
LEFT JOIN df_votos_validos v ON p.Legenda = v.NR_PARTIDO
WHERE v.CD_CARGO = 3
GROUP BY p.Sigla
HAVING SUM(v.QT_VOTOS) > 0
ORDER BY Votos DESC
")
View(votos_partido_dep_estadual_df)
votos_partido_dep_estadual_df = sqldf("
SELECT p.Sigla, SUM(v.QT_VOTOS) as Votos
FROM df_partidos p
LEFT JOIN df_votos_validos v ON p.Legenda = v.NR_PARTIDO
WHERE v.CD_CARGO = 7
GROUP BY p.Sigla
HAVING SUM(v.QT_VOTOS) > 0
ORDER BY Votos DESC
")
votos_partido_chart <- ggplot(
votos_partido_dep_estadual_df, aes(
x = reorder(Sigla, -Votos),
y = Votos,
fill=as.factor(Votos)
)
)
votos_partido_dep_estadual_chart <- ggplot(
votos_partido_dep_estadual_df, aes(
x = reorder(Sigla, -Votos),
y = Votos,
fill=as.factor(Votos)
)
)
votos_partido_dep_estadual_func <- function() {
votos_partido_dep_estadual_chart +
geom_bar(stat = "identity") +
scale_fill_grey(start = 0.65, end = 0.20) +
coord_flip() +
ggtitle(paste(title_text, 'Votos por partido')) +
xlab('Partidos') +
ylab('Qtde Votos') +
theme(legend.position="none",
plot.title = element_text(size = 11, face='bold'),
axis.title = element_text(size=12, color='black'))
}
votos_partido_dep_estadual_func()
install.packages("highcharter")
library(highcharter)
